var documenterSearchIndex = {"docs":
[{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"note: Note\nThis example corresponds to the simulations in Shi, P., Wei, M., & Barbot, S. (2022), JGR - Solid Earth - 10.1029/2022jb024069. The mesh size is reduced to improve CI/CD speed and avoid timeouts.","category":"page"},{"location":"generated/otf-with-mantle/#Problem-statement","page":"A 2D transform fault overlaying a 3D mantle","title":"Problem statement","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"We would like to investigate the stress interaction between a 2D plane transform fault and a 3D mantle and how it affects the seismic pattern.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"using Oetqf, SpecialFunctions, Optim","category":"page"},{"location":"generated/otf-with-mantle/#Generate-the-meshes","page":"A 2D transform fault overlaying a 3D mantle","title":"Generate the meshes","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Generate the mesh for the transform fault, which is suitable for using the Okada (1992) equation. The fault is 80 km long, 8 km deep, with grid sizes of 10 km and 2 km respectively, and a dip angle of 90 degrees (vertical).","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"mf = gen_mesh(Val(:RectOkada), 80e3, 8e3, 10e3, 2e3, 90.0);\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"The mesh mf is a RectOkadaMesh, which contains the fault geometry, centroid coordinates, and other properties.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Use Gmsh to generate the mantle mesh, which is suitable for using the Barbot et al. (2017) equation. The volume is 80 km long, 5 km wide, and 14 km deep, with a grid size of 4 cells along the x direction, 3 cells along the y direction, and 3 cells along the z direction. There is no refinement in the x or y direction, while cell sizes are 1.5 times progressively larger along the z axis.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"gen_gmsh_mesh(Val(:BEMHex8Mesh), -40e3, -2.5e3, -8e3, 80e3, 5e3, -22e3, 4, 3, 3;\n    output = joinpath(@__DIR__, \"mantle.vtk\"),\n    rfzh = cumprod(ones(3) * 1.5), rfy = 1.0, rfyType = \"Bump\"\n)\nma = gen_mesh(Val(:BEMHex8Mesh), joinpath(@__DIR__, \"mantle.vtk\"));\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"The mesh ma is a BEMHex8Mesh, which contains the mantle geometry, centroid coordinates, and other properties.","category":"page"},{"location":"generated/otf-with-mantle/#Compute-the-stress-Green's-functions","page":"A 2D transform fault overlaying a 3D mantle","title":"Compute the stress Green's functions","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Assume the shear modulus and the Lamé parameter are both 3e10 Pa.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"λ = μ = 3e10;\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Initialize the path to save the stress Green's functions.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"gffile = joinpath(@__DIR__, \"gf.h5\")\nisfile(gffile) && rm(gffile);\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Compute the stress Green's functions within the fault. We add a buffer zone of 1 times the fault length on both sides of the fault to avoid edge effects.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"@time gf₁₁ = stress_greens_function(mf, λ, μ; buffer_ratio = 1)\nh5write(gffile, \"gf₁₁\", gf₁₁); # fault -> fault\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Compute the stress Green's functions from the fault to the mantle.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"@time gf₁₂ = stress_greens_function(mf, ma, λ, μ; buffer_ratio = 1, qtype = \"Gauss1\")\nh5write(gffile, \"gf₁₂\", gf₁₂); # fault -> mantle\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Compute the stress Green's functions from the mantle to the fault and within the mantle.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"@time gf₂₁ = stress_greens_function(ma, mf, λ, μ)\nh5write(gffile, \"gf₂₁\", gf₂₁); # mantle -> fault\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Compute the stress Green's functions within the mantle, using Gauss1 quadrature.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"@time gf₂₂ = stress_greens_function(ma, λ, μ; qtype = \"Gauss1\")\nh5write(gffile, \"gf₂₂\", gf₂₂); # mantle -> mantle\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nThe buffer_ratio denotes the fraction of the original fault length on the two sides of the fault in which no dislocation occurs. It serves as a buffer zone to imitate the ridge section on the edges of an oceanic transform fault (personal communication with Yajing Liu). Basically, it affects how the stiffness tensor is periodically summed.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nNotice that, in Gmsh before v4.9, the quadrature type \"Gauss2\" does not stand for the product rule; instead, it is an optimized cubature rule (see this issue). For more cubature rules, see quadpy.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nIt is recommended to use at least Gauss2 quadrature for the mantle mesh to ensure the maximum real part of the eigenvalues of the stiffness tensor is small. The volumetric mean has drastically reduced it to avoid numerical instability. See the appendix of the Shi et al., 2022 for more details.","category":"page"},{"location":"generated/otf-with-mantle/#Set-up-parameters","page":"A 2D transform fault overlaying a 3D mantle","title":"Set up parameters","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Set up the rate-and-state friction parameters on the fault. We include two velocity-weakening patches on the fault: one on the left side between -25 km and -5 km, and the other on the right side between 5 km and 25 km, and the depth between -6 km and -1 km.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"cs = 3044.14 # m/s\nvpl = 140e-3 / 365 / 86400 # 140 mm/yr\nv0 = 1e-6\nf0 = 0.6\nμ = 3e10\nη = μ / 2cs # radiation damping\nν = λ / 2(λ + μ)\navw = 0.015\nabvw = 0.0047\nDc = 8e-3\nσmax = 5e7\na = ones(mf.nx, mf.nξ) .* avw\nb = ones(mf.nx, mf.nξ) .* (avw - abvw)\nL = ones(mf.nx, mf.nξ) .* Dc\nσ = [min(σmax, 1.5e6 + 18.0e3 * z) for z in -mf.z] # Pa\nσ = repeat(σ, 1, mf.nx)' |> Matrix # Pa\nleft_patch = @. -25.e3 ≤ mf.x ≤ -5.e3\nright_patch = @. 5.e3 ≤ mf.x ≤ 25.e3\nvert_patch = @. -6.e3 ≤ mf.z ≤ -1e3\nb[xor.(left_patch, right_patch), vert_patch] .= avw + abvw # assign velocity weakening\npf = RateStateQuasiDynamicProperty(a, b, L, σ, η, vpl, f0, v0)\nsave_property(joinpath(@__DIR__, \"para-fault.bson\"), pf);\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Set up rheology parameters in the mantle assuming power-law viscosity with lab-derived results.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"A_wet_dis = 3e1\nQ_wet_dis = 480e3\nV_wet_dis = 11e-6\nm_wet_dis = 0\nr_wet_dis = 1.2\nn_wet_dis = 3.5\ngrain_size = 10000.0 # μm\nCOH = 1000 # ppm / HSi\n𝙍 = 8.314 # gas constant\ncrust_depth = 7e3\nκ = 8e-7\n𝚃(z) = 1673 * erf(z / sqrt(4κ * 1e6 * 365 * 86400)) # 1 Myr OTF\n𝙿(z) = 2800 * 9.8 * crust_depth + 3300 * 9.8 * (z - crust_depth)\nprefactor_dis(z) = A_wet_dis / (1e6)^n_wet_dis * COH^r_wet_dis * grain_size^m_wet_dis * exp(-(Q_wet_dis + 𝙿(z) * V_wet_dis) / 𝙍 / 𝚃(z))\nrel_dϵ = [0.0, -1e-12, 0.0, 0.0, 0.0, 0.0]\namplifier = 1e0\nγ_dis = prefactor_dis.(-ma.cz) .* amplifier\npa = PowerLawViscosityProperty(γ_dis, ones(length(ma.cz)) * (n_wet_dis - 1), rel_dϵ) # note to save `n-1` instead of `n`, where `n` refers to the stress power\nsave_property(joinpath(@__DIR__, \"para-mantle\" * \".bson\"), pa);\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"warning: Warning\nMake sure your units are consistent across the whole variable space. Also, note that we save n-1 instead of n, where n refers to the stress power.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nTo load existing properties, use load_property(YOUR_FILE, :RateStateQuasiDynamicProperty) or load_property(YOUR_FILE, :PowerLawViscosityProperty) accordingly.","category":"page"},{"location":"generated/otf-with-mantle/#Set-up-initial-conditions","page":"A 2D transform fault overlaying a 3D mantle","title":"Set up initial conditions","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"We set up a uniform initial velocity field equal to the plate rate on the fault, with slight perturbations in the state variable of the left and right halves of the fault.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"vinit = pf.vpl .* ones(size(pf.a))\nθinit = pf.L ./ vinit\nθinit[1: size(θinit, 1) >> 1, :] ./= 1.1\nθinit[size(θinit, 1) >> 1 + 1: end, :] ./= 2.5\nδinit = zeros(size(pf.a));\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"We set up initial conditions in the mantle where the initial stress matches the background strain rate through a simple 1D optimization.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"ϵinit = zeros(length(pa.γ), 6)\nP = map(z -> 2800 * 9.8 * crust_depth + 3300 * 9.8 * (z - crust_depth), -ma.cz) # change the depth of crust\nσinit = repeat(P, 1, 6)\nσinit[:,3] .= 0.0 # xz\nσinit[:,5] .= 0.0 # yz\ntarget(i) = x -> (pa.γ[i] * (sqrt(2) * x) ^ (pa.n[i]) * x - abs(pa.dϵ₀[2])) ^ 2\nσxyinit = -map(i -> Optim.minimizer(optimize(target(i), 1e1, 1e14)), 1: length(pa.γ))\nreldϵ = map(i -> pa.γ[i] * (sqrt(2) * abs(σxyinit[i])) ^ (pa.n[i]) * σxyinit[i], 1: length(pa.γ))\n@assert all(isapprox.(reldϵ, pa.dϵ₀[2]; rtol=1e-3))\nσinit[:,2] .= σxyinit;\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/#Assemble-the-problem","page":"A 2D transform fault overlaying a 3D mantle","title":"Assemble the problem","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"Using the Green's functions, the properties, and the initial conditions, we assemble the problem. Notice the order of the variables here must be velocity, state variable, strain, stress, and slip.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"uinit = ArrayPartition(vinit, θinit, ϵinit, σinit, δinit)\nprob = assemble(gf₁₁, gf₁₂, gf₂₁, gf₂₂, pf, pa, uinit, (0.0, 0.1 * 365 * 86400));\nnothing #hide","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"We set up the saving scheme and solve the equation. Here, we will save (in the order of) velocity, state variable, strain rate, strain, stress, and slip, every 100 steps. All the variables are named exactly the same as in the equations.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"handler(u::ArrayPartition, t, integrator) = (u.x[1], u.x[2], integrator(integrator.t, Val{1}).x[3], u.x[3], u.x[4], u.x[5])\noutput = joinpath(@__DIR__, \"output.h5\")\n@time sol = wsolve(prob, VCABM5(), output, 100, handler, [\"v\", \"θ\", \"dϵ\", \"ϵ\", \"σ\", \"δ\"], \"t\";\n    reltol=1e-6, abstol=1e-8, dtmax=0.2*365*86400, dt=1e-8, maxiters=1e9, stride=100, force=true\n)","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nSee this issue to learn more about retrieving derivatives in the solution.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nWe often find that multi-step solvers like VCABM5 are more efficient than single-step solvers like Tsit5 for this kind of problem.","category":"page"},{"location":"generated/otf-with-mantle/#Analyze-the-results","page":"A 2D transform fault overlaying a 3D mantle","title":"Analyze the results","text":"","category":"section"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"The solution is saved in the output.h5 file, which contains the time series of velocity, state variable, strain rate, strain, stress, and slip. We can load the solution and analyze the results, for example, extracting the earthquake catalog from the velocity time series, visualizing the fault rupture, mantle strain flow, etc. Readers are encouraged to explore the figures in the Shi et al., 2022 for more insights.","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"tip: Tip\nTo generate the PVD files for visualization in Paraview, we can use the following functions. The output PVD file can be opened in Paraview to visualize the animation of the fault and mantle evolution. It includes the velocity and state variable on the fault and strain rate in the mantle, for all the time steps.gen_pvd(mf, joinpath(@__DIR__, \"mantle.vtk\"), output, \"t\", [\"v\", \"θ\"], [\"dϵ\"], 1: length(sol.t), joinpath(@__DIR__, \"sol.pvd\"))","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"","category":"page"},{"location":"generated/otf-with-mantle/","page":"A 2D transform fault overlaying a 3D mantle","title":"A 2D transform fault overlaying a 3D mantle","text":"This page was generated using Literate.jl.","category":"page"},{"location":"APIs/#Public-Interface","page":"APIs","title":"Public Interface","text":"","category":"section"},{"location":"APIs/#Oetqf.assemble-Tuple{AbstractArray, AbstractMatrix, AbstractMatrix, AbstractMatrix, RateStateQuasiDynamicProperty, Oetqf.ViscosityProperty, ArrayPartition, Tuple{T, T} where T}","page":"APIs","title":"Oetqf.assemble","text":"assemble(gf₁₁::AbstractArray, gf₁₂::AbstractMatrix, gf₂₁::AbstractMatrix, gf₂₂::AbstractMatrix,\n         pf::RateStateQuasiDynamicProperty, pa::ViscosityProperty, u0::ArrayPartition, tspan::NTuple{2};\n         se::StateEvolutionLaw=DieterichStateLaw(), kwargs...)\n\nConstruct an ODEProblem for viscoelastic rate-and-state friction model with quasi-dynamic evolution.\n\nArguments\n\ngf₁₁: Greens function array for fault-fault interaction\ngf₁₂: Greens function array for fault-mantle interaction\ngf₂₁: Greens function array for mantle-fault interaction\ngf₂₂: Greens function array for mantle-mantle interaction\npf: rate-and-state quasi-dynamic property for fault\npa: viscosity property for mantle\nu0: initial state partition, must be an ArrayPartition with 5 components: velocity, state variable, strain, stress, and fault slip\ntspan: time span for the simulation, a tuple of two values (start, stop)\nse: state evolution law, defaults to DieterichStateLaw()\n\nReturns\n\nAn ODEProblem object that can be solved using OrdinaryDiffEq.jl\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.assemble-Tuple{AbstractArray, RateStateQuasiDynamicProperty, ArrayPartition, Tuple{T, T} where T}","page":"APIs","title":"Oetqf.assemble","text":"assemble(gf::AbstractArray, p::RateStateQuasiDynamicProperty, u0::ArrayPartition, tspan::NTuple{2};\n         se::StateEvolutionLaw=DieterichStateLaw(), kwargs...)\n\nConstruct an ODEProblem for rate-and-state friction model with quasi-dynamic evolution.\n\nArguments\n\ngf: Greens function array for the fault\np: rate-and-state quasi-dynamic property\nu0: initial state partition, must be an ArrayPartition with 3 components: velocity, state variable, and fault slip\ntspan: time span for the simulation, a tuple of two values (start, stop)\nse: state evolution law, defaults to DieterichStateLaw()\n\nReturns\n\nAn ODEProblem object that can be solved using OrdinaryDiffEq.jl.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.assemble-Tuple{AbstractArray, RateStateQuasiDynamicProperty, DilatancyProperty, ArrayPartition, Tuple{T, T} where T}","page":"APIs","title":"Oetqf.assemble","text":"assemble(gf::AbstractArray, p::RateStateQuasiDynamicProperty, dila::DilatancyProperty, u0::ArrayPartition, tspan::NTuple{2};\n         se::StateEvolutionLaw=DieterichStateLaw(), kwargs...)\n\nConstruct an ODEProblem for rate-and-state friction model with dilatancy and quasi-dynamic evolution.\n\nArguments\n\ngf: Greens function array for the fault\np: rate-and-state quasi-dynamic property\ndila: dilatancy property\nu0: initial state partition, must be an ArrayPartition with 4 components: velocity, state variable, pressure, and fault slip\ntspan: time span for the simulation, a tuple of two values (start, stop)\nse: state evolution law, defaults to DieterichStateLaw()\n\nReturns\n\nAn ODEProblem object that can be solved using OrdinaryDiffEq.jl\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gen_gmsh_mesh-Union{Tuple{I}, Tuple{T}, Tuple{Val{:BEMHex8Mesh}, T, T, T, T, T, T, I, I, I}} where {T, I}","page":"APIs","title":"Oetqf.gen_gmsh_mesh","text":"gen_gmsh_mesh(::Val{:BEMHex8Mesh},\n    llx::T, lly::T, llz::T, dx::T, dy::T, dz::T, nx::I, ny::I, nz::I;\n    rfx::T=one(T), rfy::T=one(T), rfzh::AbstractVector=ones(nz),\n    rfxType::AbstractString=\"Bump\", rfyType::AbstractString=\"Bump\",\n    output::AbstractString=\"temp.msh\"\n) where {T, I}\n\nGernate a box using 8-node hexahedron elements by vertically extruding transfinite curve on xy plane, allowing     total flexibility on the mesh size in z direction, and refinement in xy plane.\n\nArguments\n\nllx, lly, llz: coordinates of low-left corner on the top surface\ndx, dy, dz: x-, y-, z-extension\nnx, ny: number of cells along x-, y-axis\nrfx, rfy: refinement coefficients along x-, y-axis using Bump algorithm, please refer gmsh.model.geo.mesh.setTransfiniteCurve\nrfzh: accumulated height of cells along z-axis which will be normalized automatically, please refer heights in gmsh.model.geo.extrude\n\nReturns\n\nA GMSH mesh file of the BEMHex8Mesh` for the mantle deformation modeling.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gen_mesh-Tuple{Val{:BEMHex8Mesh}, AbstractString}","page":"APIs","title":"Oetqf.gen_mesh","text":"gen_mesh(::Val{:BEMHex8Mesh}, file::AbstractString;\n    rotation::Real=0.0, transpose::Bool=false)\n\nLoad a BEM Hex8 mesh from a GMSH file.\n\nArguments\n\nfile::AbstractString: path to the GMSH mesh file\nrotation::Real=0.0: rotation angle in degrees to apply to the mesh\ntranspose::Bool=false: if true, transpose the mesh coordinates\n\nReturns\n\nA BEMHex8Mesh object representing the mantle mesh for modeling.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gen_mesh-Union{Tuple{T}, Tuple{Val{:RectOkada}, Vararg{T, 5}}} where T","page":"APIs","title":"Oetqf.gen_mesh","text":"gen_mesh(::Val{:RectOkada},\n    x::T, ξ::T, Δx::T, Δξ::T, dip::T) where T\n\nGenerate a rectangular mesh for Okada's fault model in 2D.\n\nArguments\n\nx: length of the fault along strike\nξ: length of the fault along downdip\nΔx: cell size along strike\nΔξ: cell size along downdip\ndip: dipping angle of the fault in degrees\n\nReturns\n\nA RectOkadaMesh object representing the transfinite mesh suitable for fault modeling.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gen_pvd-Tuple{Oetqf.RectOkadaMesh, Vararg{Any, 7}}","page":"APIs","title":"Oetqf.gen_pvd","text":"gen_pvd(mf::RectOkadaMesh, mafile, solh5, tstr, ufstrs, uastrs, steps, output;\n    tscale=365*86400, mafiletype=Val(:BEMHex8Mesh))\n\nThis function generates a Paraview collection file from the Okada mesh (fault plane) and the volume mesh, and solution data stored in an HDF5 file.\n\nArguments\n\nmf::RectOkadaMesh: the rectangular Okada mesh object\nmafile: the mesh file for the BEM model\nsolh5: the HDF5 file containing the solution data\ntstr: the name of the time data in the HDF5 file\nufstrs: a vector of strings representing the names of the solution components (fault) in the HDF5 file\nuastrs: a vector of strings representing the names of the solution components (mantle) in the HDF5 file\nsteps: a vector of integers representing the time steps to be included in the output\noutput: the output directory for the Paraview collection file\ntscale: a scaling factor for the time data (default is 365*86400 seconds, which is one year)\nmafiletype: the type of the mesh file, default is :BEMHex8Mesh, which indicates a BEM mesh with Hex8 elements\n\nReturns\n\nA Paraview collection file containing the mesh and solution data at specified time steps.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gen_vtk_grid-Tuple{Oetqf.RectOkadaMesh}","page":"APIs","title":"Oetqf.gen_vtk_grid","text":"gen_vtk_grid(mesh::RectOkadaMesh)\n\nThis function creates a grid suitable for visualization in Paraview or similar tools.\n\nArguments\n\nmesh::RectOkadaMesh: the rectangular Okada mesh object\n\nReturns\n\nA tuple containing the x, y, and z coordinates of the grid points.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gen_vtk_grid-Tuple{Val{:BEMHex8Mesh}, Any}","page":"APIs","title":"Oetqf.gen_vtk_grid","text":"gen_vtk_grid(t::Val{:BEMHex8Mesh}, mesh)\n\nThis function uses GMSH to read the Hex8 mesh and convert it into a VTK grid format     for visualization in Paraview or similar tools.\n\nArguments\n\nt::Val{:BEMHex8Mesh}: a value type indicating the mesh type\nmesh: the mesh object to be converted\n\nReturns\n\nA tuple containing the points and cells of the mesh in VTK format.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.gmsh_quadrature-Tuple{Integer, String}","page":"APIs","title":"Oetqf.gmsh_quadrature","text":"gmsh_quadrature(etype::Integer, qtype::String)::QuadratureType\n\nThis function retrieves the integration points and weights for a given element type and quadrature type from GMSH.\n\nArguments\n\netype::Integer: the element type ID in GMSH\nqtype::String: the quadrature type, e.g., \"Gauss1\"\n\nReturns\n\nA tuple containing the local coordinates and weights for the quadrature points.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.stress_greens_function-Union{Tuple{T}, Tuple{Oetqf.BEMHex8Mesh, Oetqf.RectOkadaMesh, T, T}} where T","page":"APIs","title":"Oetqf.stress_greens_function","text":"stress_greens_function(ma::BEMHex8Mesh, mf::RectOkadaMesh, λ::T, μ::T;\n    ftype::FaultType=StrikeSlip(),\n) where {T}\n\nThis function computes the stress Green's function for a source in Hex8 mesh to a receiver on Okada mesh.\n\nArguments\n\nma::BEMHex8Mesh: the BEM Hex8 mesh object\nmf::RectOkadaMesh: the rectangular Okada mesh object\nλ::T: Lamé's first parameter\nμ::T: shear modulus\nftype::FaultType=StrikeSlip(): type of fault, either StrikeSlip or DipSlip\n\nReturns\n\nA 2D array of stress Green's functions, where each column corresponds to a source\n\nmantle patch and each row corresponds to a receiver fault patch.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.stress_greens_function-Union{Tuple{T}, Tuple{Oetqf.BEMHex8Mesh, T, T}} where T","page":"APIs","title":"Oetqf.stress_greens_function","text":"stress_greens_function(\n    mesh::BEMHex8Mesh,\n    λ::T, μ::T;\n    qtype::Union{String, Tuple{AbstractVecOrMat, AbstractVector}}=\"Gauss1\",\n    checkeigvals::Bool=true,\n) where {T}\n\nThis function computes the stress Green's function for a BEM Hex8 mesh.\n\nArguments\n\nmesh::BEMHex8Mesh: the BEM Hex8 mesh object\nλ::T: Lamé's first parameter\nμ::T: shear modulus\nqtype::Union{String, Tuple{AbstractVecOrMat, AbstractVector}} quadrature type for integration, can be a string or a tuple of local coordinates and weights\ncheckeigvals::Bool=true: if true, check the eigenvalues of the resulting stress matrix and print the maximum real part   \n\nReturns\n\nA 2D array of stress Green's functions, where each column corresponds to a source\n\nmantle patch and each row corresponds to another mantle patch.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.stress_greens_function-Union{Tuple{T}, Tuple{Oetqf.RectOkadaMesh, Oetqf.BEMHex8Mesh, T, T}} where T","page":"APIs","title":"Oetqf.stress_greens_function","text":"stress_greens_function(\n    mf::RectOkadaMesh, ma::BEMHex8Mesh,\n    λ::T, μ::T;\n    ftype::FaultType=StrikeSlip(),\n    qtype::Union{String, Tuple{AbstractVecOrMat, AbstractVector}}=\"Gauss1\",\n    nrept::Integer=2, buffer_ratio::Real=0,\n) where {T}\n\nThis function computes the stress Green's function for a source in Okada mesh to a receiver on Hex8 mesh.\n\nArguments\n\nmf::RectOkadaMesh: the rectangular Okada mesh object\nma::BEMHex8Mesh: the BEM Hex8 mesh object\nλ::T: Lamé's first parameter            \nμ::T: shear modulus\nftype::FaultType=StrikeSlip(): type of fault, either StrikeSlip or DipSlip\nqtype::Union{String, Tuple{AbstractVecOrMat, AbstractVector}}: quadrature type for integration, can be a string or a tuple of local coordinates and weights\nnrept::Integer=2: number of repetitions for the dislocation\nbuffer_ratio::Real=0: ratio of buffer zone around the mesh  \n\nReturns\n\nA 2D array of stress Green's functions, where each column corresponds to a source fault patch \n\nand each row corresponds to a receiver mantle patch.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.stress_greens_function-Union{Tuple{T}, Tuple{Oetqf.RectOkadaMesh, T, T}} where T<:Real","page":"APIs","title":"Oetqf.stress_greens_function","text":"stress_greens_function(mesh::RectOkadaMesh, λ::T, μ::T;\n    ftype::FaultType=StrikeSlip(), fourier::Bool=true,\n    nrept::Integer=2, buffer_ratio::Real=0, fftw_flags::UInt32=FFTW.PATIENT\n) where {T <: Real}\n\nThis function computes the stress Green's function for a rectangular Okada mesh fault.\n\nArguments\n\nmesh::RectOkadaMesh: the rectangular Okada mesh object\nλ::T: Lamé's first parameter\nμ::T: shear modulus\nftype::FaultType=StrikeSlip(): type of fault, either StrikeSlip or DipSlip\nfourier::Bool=true: if true, return the Fourier transform of the Green's function\nnrept::Integer=2: number of repetitions for the dislocation\nbuffer_ratio::Real=0: ratio of buffer zone around the mesh\nfftw_flags::UInt32=FFTW.PATIENT: flags for FFTW plan\n\nReturns\n\nIf fourier is true, returns the Fourier transform of the stress Green's function,    otherwise, returns the stress Green's function as a 3D array. The array considers the    translational symmetry of the transfinite mesh.\n\n\n\n\n\n","category":"method"},{"location":"APIs/#Oetqf.wsolve-Tuple{ODEProblem, OrdinaryDiffEqCore.OrdinaryDiffEqAlgorithm, Vararg{Any, 5}}","page":"APIs","title":"Oetqf.wsolve","text":"wsolve(prob::ODEProblem, alg::OrdinaryDiffEqAlgorithm,\n    file, nstep, getu, ustrs, tstr; kwargs...)\n\nWrite the solution to HDF5 file while solving the ODE. The interface     is exactly the same as     solve an ODEProblem     except a few more about the saving procedure. Notice, it will set     save_everystep=false so to avoid memory blow up. The return code     will be written as an attribute in tstr data group.\n\nExtra Arguments\n\nfile::AbstractString: name of file to be saved\nnstep::Integer: number of steps after which a saving operation will be performed\ngetu::Function: function handler to extract desired solution for saving, which should have the signature   getu(u, t, integrator), where u is the current solution, t is the current time,   and integrator is the current integrator object. The output should be a tuple of   arrays or vectors to be saved.\nustr::AbstractVector: list of names to be assigned for each components, whose   length must equal the length of getu output\ntstr::AbstractString: name of time data\n\nKWARGS\n\nstride::Integer=1: downsampling rate for saving outputs\nappend::Bool=false: if true then append solution after the end of file\nforce::Bool=false: force to overwrite the existing solution file\n\nReturns\n\nsol::ODESolution: the solution object of OrdinaryDiffEq.jl\n\n\n\n\n\n","category":"method"},{"location":"testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"testing/#Unit-Testing","page":"Testing","title":"Unit Testing","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"We use GitHub Actions for continuous integration. The tests cover:","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"ODE solution storage with HDF5\nPVD generation from solution outputs\nBLAS backend switching\nMesh generation (built-in transfinite fault and GMSH)\nODE assembly for various problem types\nDomain properties loading and saving\nViscoelastic laws\nFFT convolution for translational symmetry Green's function","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"To run the tests locally:","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"(@v1.11) pkg> activate .\n    Activating project at `~/Projects/Oetqf.jl`\n\n(Oetqf) pkg> test","category":"page"},{"location":"testing/#Integration-Testing","page":"Testing","title":"Integration Testing","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"A notebook example provides integration testing, demonstrating end-to-end simulation of earthquake cycles on a plane fault coupled with a viscoelastic mantle. This notebook is included in the continuous deployment.","category":"page"},{"location":"testing/#Supported-Environment","page":"Testing","title":"Supported Environment","text":"","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"OS Architecture Julia Version\nubuntu-latest x64 v1.11","category":"page"},{"location":"testing/","page":"Testing","title":"Testing","text":"note: Note\nDue to resource limitation on GitHub, we only include Linux building in the CI/CD. This package has been manually tested on macOS.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is used to simulate the quasi-dynamic earthquake cycles under the framework of rate-and-state friction on a transfinite-mesh transform fault overlaying a viscoelastic hexahedron-mesh mantle using boundary-element-method (BEM). This package is an updated subset version of Quaycle.jl which includes dipping fault, triangular-mesh (fault) and tetrahedron-mesh (mantle).","category":"page"},{"location":"#Supported-physics","page":"Home","title":"Supported physics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this package, for frictional law we support DieterichStateLaw. For rate-and-state friction, we support the regularized form and dilatancy machanism. For viscoelasticity, we support power-law rheology. Users can extend new physics by implementing new equations, providing new parameters if necessary, and aseembling them into the ODE function. Please see the existing ODE functions to get started.","category":"page"},{"location":"#Thrid-party-libraries","page":"Home","title":"Thrid-party libraries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses HDF5 to save the numerical output for further analysis. It also supports writing output into VTK for visualization and animation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A collection of commonly used Green's functions can be accessed at GeoGreensFunctions.jl. The package uses Gmsh for domain discreitzation. See GmshTools.jl also for a more convenient way to use Gmsh in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install this package of a specific version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.11) pkg> add https://github.com/shipengcheng1230/Oetqf.jl#v0.3.1","category":"page"},{"location":"#Known-Issues","page":"Home","title":"Known Issues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The competition between Julia threads and BLAS threads when hyperthreading is disabled, see this example.","category":"page"},{"location":"parameters/#Model-Parameters","page":"Parameters","title":"Model Parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"We name all the parameters the same as they appear in various literatures.","category":"page"},{"location":"parameters/#Fault-Parameter-Space","page":"Parameters","title":"Fault Parameter Space","text":"","category":"section"},{"location":"parameters/#RateStateQuasiDynamicProperty","page":"Parameters","title":"RateStateQuasiDynamicProperty","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Name Type Description\na Array{<:Real} Direct effect parameter\nb Array{<:Real} Evolution effect parameter\nL Array{<:Real} Critical slip distance\nσ Array{<:Real} Effective normal stress\nη Real Radiation damping coefficient\nvpl Real Plate velocity (loading rate)\nf₀ Real Reference friction coefficient\nv₀ Real Reference slip velocity","category":"page"},{"location":"parameters/#DilatancyProperty","page":"Parameters","title":"DilatancyProperty","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Name Type Description\ntₚ Array{<:Real} Characteristic diffusion timescale\nϵ Array{<:Real} Dilatancy coefficient\nβ Array{<:Real} Fault gouge bulk compressibility\np₀ Array{<:Real} Ambient pore pressure","category":"page"},{"location":"parameters/#Mantle-Parameter-Space","page":"Parameters","title":"Mantle Parameter Space","text":"","category":"section"},{"location":"parameters/#PowerLawViscosityProperty","page":"Parameters","title":"PowerLawViscosityProperty","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Name Type Description\nγ Array{<:Real} Power law coefficient\nn Array{<:Real} (Power - 1) of the stress term\ndϵ₀ Vector{<:Real} Reference strain rate","category":"page"},{"location":"parameters/#CompositePowerLawViscosityProperty","page":"Parameters","title":"CompositePowerLawViscosityProperty","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Name Type Description\npiter Vector{<:ViscosityProperty} Series of different viscosity laws\ndϵ₀ Vector{<:Real} Reference strain rate","category":"page"}]
}
